// Prisma schema for the shared database package
// Default to PostgreSQL via DATABASE_URL. For Prisma Accelerate (rust-free engine)
// use the generator option `engineType = "dataproxy"` and set an Accelerate URL in DATABASE_URL.
// Optionally set DIRECT_URL for migrations from local/dev.

generator client {
    provider     = "prisma-client"
    output       = "../src/generated"
    moduleFormat = "esm"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

enum Proxy {
    SEASTACK_TREAFIK
    SEASTACK_NGINX
}

/**
 * Better Auth Models
 */

model User {
    id            String    @id
    name          String
    email         String
    emailVerified Boolean   @default(false)
    image         String?
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @default(now()) @updatedAt
    sessions      Session[]
    accounts      Account[]
    apikeys       Apikey[]

    members     Member[]
    invitations Invitation[]

    passkeys Passkey[]

    @@unique([email])
    @@map("user")
}

model Session {
    id        String   @id
    expiresAt DateTime
    token     String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    ipAddress String?
    userAgent String?
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    activeOrganizationId String?

    @@unique([token])
    @@map("session")
}

model Account {
    id                    String    @id
    accountId             String
    providerId            String
    userId                String
    user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    accessToken           String?
    refreshToken          String?
    idToken               String?
    accessTokenExpiresAt  DateTime?
    refreshTokenExpiresAt DateTime?
    scope                 String?
    password              String?
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    @@map("account")
}

model Verification {
    id         String   @id
    identifier String
    value      String
    expiresAt  DateTime
    createdAt  DateTime @default(now())
    updatedAt  DateTime @default(now()) @updatedAt

    @@map("verification")
}

model Apikey {
    id                  String    @id
    name                String?
    start               String?
    prefix              String?
    key                 String
    userId              String
    user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    refillInterval      Int?
    refillAmount        Int?
    lastRefillAt        DateTime?
    enabled             Boolean?  @default(true)
    rateLimitEnabled    Boolean?  @default(true)
    rateLimitTimeWindow Int?
    rateLimitMax        Int?
    requestCount        Int?
    remaining           Int?
    lastRequest         DateTime?
    expiresAt           DateTime?
    createdAt           DateTime
    updatedAt           DateTime
    permissions         String?
    metadata            String?

    @@map("apikey")
}

model Organization {
    id                    String                 @id
    name                  String
    slug                  String
    logo                  String?
    createdAt             DateTime
    metadata              String?
    members               Member[]
    invitations           Invitation[]
    projects              Project[]
    servers               Server[]
    sshKeys               SSHKey[]
    registries            Registry?              @relation(fields: [registryId], references: [id])
    registryId            String?
    notificationProviders NotificationProvider[]
    notifications         Notification[]
    storageDestinations   StorageDestination[]

    @@unique([slug])
    @@map("organization")
}

model Member {
    id             String       @id
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    userId         String
    user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
    role           String
    createdAt      DateTime

    @@map("member")
}

model Invitation {
    id             String       @id
    organizationId String
    organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    email          String
    role           String?
    status         String
    expiresAt      DateTime
    inviterId      String
    user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

    @@map("invitation")
}

model Passkey {
    id           String    @id
    name         String?
    publicKey    String
    userId       String
    user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    credentialID String
    counter      Int
    deviceType   String
    backedUp     Boolean
    transports   String?
    createdAt    DateTime?
    aaguid       String?

    @@map("passkey")
}

model Project {
    id                     String                  @id @default(cuid(2))
    name                   String
    description            String?
    deploymentEnvironments DeploymentEnvironment[]
    environmentVariables   String                  @default("")
    organizations          Organization[]
}

model DeploymentEnvironment {
    id                   String    @id @default(cuid(2))
    name                 String    @default("production")
    services             Service[]
    project              Project   @relation(fields: [projectId], references: [id])
    projectId            String
    environmentVariables String    @default("")
}

model Service {
    id                      String                @id @default(uuid())
    name                    String
    description             String?
    deploymentEnvironment   DeploymentEnvironment @relation(fields: [deploymentEnvironmentId], references: [id])
    deploymentEnvironmentId String
    environmentVariables    String                @default("")
    server                  Server                @relation(fields: [serverId], references: [id])
    serverId                String
    swarmService            SwarmService?
    domains                 Domain[]
    networks                Network[]
    deployments             Deployment[]
    volumes                 Volume[]
}

model SwarmService {
    id         String    @id
    service    Service   @relation(fields: [id], references: [id], onDelete: Cascade)
    image      String
    replicas   Int?
    registry   Registry? @relation(fields: [registryId], references: [id])
    registryId String?
}

model Domain {
    id                String  @id @default(uuid())
    domain            String  @unique
    internalPort      Int
    internalContainer String?
    https             Boolean
    service           Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
    serviceId         String
}

model Server {
    id       String    @id @default(cuid(2))
    name     String
    services Service[]
    hostname String
    port     Int
    user     String
    key      SSHKey    @relation(fields: [SSHKeyId], references: [id])
    SSHKeyId String
    proxy    Proxy     @default(SEASTACK_TREAFIK)

    organizations Organization[]
    registries    Registry[]
    networks      Network[]
}

model SSHKey {
    id            String         @id @default(cuid(2))
    name          String
    // Encrypted private key
    privateKey    String
    publicKey     String
    servers       Server[]
    organizations Organization[]
}

model Registry {
    id            String         @id @default(cuid(2))
    name          String
    url           String
    username      String
    // Encrypted password
    password      String
    organizations Organization[]
    servers       Server[]
    swarmServices SwarmService[]
}

model Network {
    id          String  @id @default(cuid(2))
    name        String
    description String?
    driver      String  @default("overlay")
    subnet      String?
    gateway     String?
    attachable  Boolean @default(false)
    labels      Json?
    options     Json?

    attachToReverseProxy Boolean   @default(false)
    services             Service[]
    server               Server    @relation(fields: [serverId], references: [id])
    serverId             String
}

enum DeploymentStatus {
    PENDING
    SUCCESS
    FAILED
}

model Deployment {
    id String @id @default(uuid(7))

    createdAt DateTime         @default(now())
    updatedAt DateTime         @updatedAt
    status    DeploymentStatus @default(PENDING)

    service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
    serviceId String
}

model Volume {
    id        String  @id @default(cuid(2))
    name      String
    mountPath String
    readOnly  Boolean @default(false)
    service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
    serviceId String
}

model NotificationProvider {
    id                           String                        @id @default(cuid(2))
    name                         String
    organizations                Organization[]
    SMTPNotificationProvider     SMTPNotificationProvider?
    DiscordNotificationProvider  DiscordNotificationProvider?
    TelegramNotificationProvider TelegramNotificationProvider?
    notifications                Notification[]
}

model SMTPNotificationProvider {
    id          String               @id
    provider    NotificationProvider @relation(fields: [id], references: [id], onDelete: Cascade)
    host        String
    port        Int
    username    String
    // Encrypted password
    password    String
    fromAddress String
}

model DiscordNotificationProvider {
    id       String               @id
    provider NotificationProvider @relation(fields: [id], references: [id], onDelete: Cascade)
    webhook  String
}

model TelegramNotificationProvider {
    id       String               @id
    provider NotificationProvider @relation(fields: [id], references: [id], onDelete: Cascade)
    token    String
    chatId   String
}

model Notification {
    /**
     * This notifications structure allows us to send notifications to multiple providers
     * and could also be extended to support adding notifications and notifications providers on the user account.
     */
    id                     Int                  @id @default(autoincrement())
    type                   String
    organization           Organization         @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    organizationId         String
    provider               NotificationProvider @relation(fields: [notificationProviderId], references: [id], onDelete: Cascade)
    notificationProviderId String

    @@unique([type, organizationId, notificationProviderId])
}

model StorageDestination {
    id                    String                 @id @default(cuid(2))
    name                  String
    S3Storage             S3Storage?
    organizations         Organization[]
    volumeBackupSchedules VolumeBackupSchedule[]
}

model S3Storage {
    id          String             @id
    destination StorageDestination @relation(fields: [id], references: [id], onDelete: Cascade)
    bucket      String
    endpoint    String
    region      String?

    // Encrypted credentials
    accessKeyId     String
    secretAccessKey String

    usePathStyle Boolean @default(false)
}

model VolumeBackupSchedule {
    id String @id @default(cuid(2))

    destination          StorageDestination @relation(fields: [storageDestinationId], references: [id], onDelete: Cascade)
    storageDestinationId String
    cron                 String
    retention            String
    isActive             Boolean
    runs                 BackupRun[]
}

enum BackupRunStatus {
    FAILED
    SUCCESS
    RUNNING
}

model BackupRun {
    id        String          @id @default(uuid(7))
    status    BackupRunStatus @default(RUNNING)
    createdAt DateTime        @default(now())
    updatedAt DateTime        @updatedAt()

    artifactLocation String?

    volumeBackupSchedule   VolumeBackupSchedule? @relation(fields: [volumeBackupScheduleId], references: [id], onDelete: Cascade)
    volumeBackupScheduleId String?
}
